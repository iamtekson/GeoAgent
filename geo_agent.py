# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoAgent
                                 A QGIS plugin
 Plugin for geospatial workflow
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Tek Kshetri
        email                : iamtekson@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QSizePolicy, QProgressDialog
from qgis.PyQt.QtGui import QFont
from qgis.core import Qgis, QgsMessageLog

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .geo_agent_dialog import GeoAgentDialog

# Import agent and LLM components
from .config.settings import (
    API_KEY_FILE,
    SUPPORTED_MODELS,
    DEFAULT_MODEL,
    DEBUG_MODE,
    QGIS_MESSAGE_DURATION,
)
from .llm.client import create_llm, ollama_model_exists, ollama_pull_model
from .prompts.system import GENERAL_SYSTEM_PROMPT
import importlib
import subprocess
import sys
import re

import os
import os.path
import traceback


class GeoAgent:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "GeoAgent_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&GeoAgent")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Agent and LLM components
        self.llm = None
        self.app = None
        self.current_model = DEFAULT_MODEL
        self.api_key = self._load_api_key()
        self.thread_id = "geo-agent"
        self._has_started_thread = False
        self._last_temperature = None
        self._error_log_path = os.path.join(self.plugin_dir, "geo_agent_error.log")

    def _log_error(self, context: str, exc: Exception):
        try:
            details = traceback.format_exc()
            # Write to plugin error log file
            with open(self._error_log_path, "a", encoding="utf-8") as f:
                f.write(f"[{context}] {str(exc)}\n")
                f.write(details + "\n\n")
            # Also send to QGIS log panel
            QgsMessageLog.logMessage(details, "GeoAgent", level=Qgis.Critical)
        except Exception:
            pass

    def _ensure_dependencies_installed(self):
        """Ensure required Python packages are installed via pyproject.toml."""
        pkg_to_import = {
            "langgraph": "langgraph",
            "langchain-core": "langchain_core",
            "langchain-community": "langchain_community",
            "langchain-openai": "langchain_openai",
            "langchain-google-genai": "langchain_google_genai",
            "langchain-ollama": "langchain_ollama",
            "requests": "requests",
        }

        # Read dependencies from pyproject.toml
        deps = []
        pyproject_path = os.path.join(self.plugin_dir, "pyproject.toml")
        try:
            with open(pyproject_path, "r", encoding="utf-8") as f:
                content = f.read()
            try:
                import tomllib  # Python 3.11+

                data = tomllib.loads(content)
                deps = data.get("project", {}).get("dependencies", []) or []
            except Exception:
                m = re.search(r"dependencies\s*=\s*\[(.*?)\]", content, re.S)
                if m:
                    raw = m.group(1)
                    for line in raw.splitlines():
                        line = line.strip().strip(",")
                        if not line:
                            continue
                        if line.startswith('"') and line.endswith('"'):
                            deps.append(line[1:-1])
        except Exception:
            deps = []

        # Normalize package names (strip version specifiers)
        pkgs = []
        for d in deps:
            name = d.split(";")[0].split(" ")[0]
            name = name.split(">=")[0].split("==")[0]
            pkgs.append(name)

        # Determine missing based on import availability
        missing = []
        for pkg in pkgs:
            import_name = pkg_to_import.get(pkg)
            if not import_name:
                continue
            try:
                importlib.import_module(import_name)
            except Exception:
                missing.append(pkg)

        if not missing:
            return True

        # Ask user to confirm installation
        try:
            pkg_list = "\n".join(missing)
            reply = QMessageBox.question(
                self.iface.mainWindow(),
                "Install Dependencies",
                f"The following packages are required:\n\n{pkg_list}\n\nInstall now?",
                QMessageBox.Yes | QMessageBox.No,
            )
            if reply != QMessageBox.Yes:
                return False
        except Exception:
            pass

        # Inform user via message bar
        try:
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Installing missing dependencies: {' '.join(missing)}",
                level=Qgis.Info,
                duration=0,
            )
        except Exception:
            pass

        # Install missing packages
        try:
            py_exec = sys.executable
            lower = py_exec.lower()
            if lower.endswith("qgis-bin.exe") or lower.endswith("qgis-ltr-bin.exe"):
                py_exec = os.path.join(os.path.dirname(py_exec), "python.exe")
            elif lower.endswith("pythonw.exe"):
                py_exec = os.path.join(os.path.dirname(py_exec), "python.exe")

            # Progress dialog during installation
            progress = None
            try:
                progress = QProgressDialog(
                    "Installing dependencies...",
                    None,
                    0,
                    len(missing),
                    self.iface.mainWindow(),
                )
                progress.setWindowTitle("GeoAgent")
                progress.setWindowModality(Qt.ApplicationModal)
                progress.setAutoClose(True)
                progress.setAutoReset(True)
                progress.setMinimumDuration(0)
            except Exception:
                progress = None

            for idx, pkg in enumerate(missing, start=1):
                subprocess.run(
                    [py_exec, "-m", "pip", "install", "--upgrade", pkg], check=True
                )
                try:
                    if progress:
                        progress.setValue(idx)
                        QCoreApplication.processEvents()
                except Exception:
                    pass

            self.iface.messageBar().pushMessage(
                "GeoAgent",
                "Dependencies installed successfully.",
                level=Qgis.Success,
                duration=QGIS_MESSAGE_DURATION,
            )
            try:
                if progress:
                    progress.close()
            except Exception:
                pass
            return True
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Failed to install dependencies: {e}",
                level=Qgis.Critical,
                duration=QGIS_MESSAGE_DURATION,
            )

    def _get_message_classes(self):
        msgs_mod = importlib.import_module("langchain_core.messages")
        return msgs_mod.SystemMessage, msgs_mod.HumanMessage

    def _get_agents_general(self):
        mod = importlib.import_module(".agents.general", package=__package__)
        return mod.build_graph_app, mod.invoke_app

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("GeoAgent", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/geo_agent/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("geoAgent"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&GeoAgent"), action)
            self.iface.removeToolBarIcon(action)

        if hasattr(self, "dlg"):
            self.iface.removeDockWidget(self.dlg)

    def run(self):
        """Run method that performs all the real work"""
        # Ensure dependencies before loading graph or message classes
        self._ensure_dependencies_installed()

        # Initialize QGIS interface for tools
        try:
            from .tools.io import set_qgis_interface

            set_qgis_interface(self.iface)
        except Exception as e:
            self._log_error("initialize_tools_interface", e)

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GeoAgentDialog(self.iface.mainWindow())
            # Prefer bottom dock area and allow only bottom
            try:
                self.dlg.setAllowedAreas(Qt.BottomDockWidgetArea)
            except Exception:
                pass
            self.iface.addDockWidget(Qt.BottomDockWidgetArea, self.dlg)
            # Encourage larger content footprint in bottom area
            try:
                # Increase minimum height on dock and its main widget if accessible
                self.dlg.setMinimumHeight(300)
                if hasattr(self.dlg, "widget") and callable(
                    getattr(self.dlg, "widget")
                ):
                    w = self.dlg.widget()
                    if w is not None:
                        w.setMinimumHeight(300)
                        sp = w.sizePolicy()
                        sp.setVerticalPolicy(QSizePolicy.Expanding)
                        sp.setHorizontalPolicy(QSizePolicy.Expanding)
                        w.setSizePolicy(sp)
            except Exception:
                pass
            # Wire up UI actions
            if hasattr(self.dlg, "send_chat"):
                try:
                    self.dlg.send_chat.clicked.disconnect()
                except Exception:
                    pass
                self.dlg.send_chat.clicked.connect(self.send_message)
            if hasattr(self.dlg, "question") and hasattr(
                self.dlg.question, "returnPressed"
            ):
                try:
                    self.dlg.question.returnPressed.disconnect()
                except Exception:
                    pass
                self.dlg.question.returnPressed.connect(self.send_message)
            # Wire up export and clear buttons
            if hasattr(self.dlg, "export_ans"):
                try:
                    self.dlg.export_ans.clicked.disconnect()
                except Exception:
                    pass
                self.dlg.export_ans.clicked.connect(self.export_chat)
            if hasattr(self.dlg, "clear_ans"):
                try:
                    self.dlg.clear_ans.clicked.disconnect()
                except Exception:
                    pass
                self.dlg.clear_ans.clicked.connect(self.clear_chat)

        # show and focus the dock widget
        self.dlg.show()
        self.dlg.raise_()
        self.dlg.activateWindow()
        # Try to give it a reasonable initial height in bottom area
        try:
            # Ask for more vertical space in bottom dock area
            self.iface.mainWindow().resizeDocks([self.dlg], [300], Qt.Vertical)
        except Exception:
            pass

    def showMessage(self, title, msg, button, icon, fontsize=9):
        msgBox = QMessageBox()
        if icon == "Warning":
            msgBox.setIcon(QMessageBox.Warning)
        if icon == "Info":
            msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(title)
        msgBox.setText(msg)
        msgBox.setStandardButtons(QMessageBox.Ok)
        msgBox.setStyleSheet(
            "background-color: rgb(83, 83, 83);color: rgb(255, 255, 255);"
        )
        font = QFont()
        font.setPointSize(fontsize)
        msgBox.setFont(font)
        msgBox.setWindowFlags(Qt.Dialog | Qt.WindowStaysOnTopHint)
        buttonY = msgBox.button(QMessageBox.Ok)
        buttonY.setText(button)
        buttonY.setFont(font)
        msgBox.exec_()

    def send_message(self):
        """Send a message and get a response from the LLM."""
        # Validate input
        question = self.dlg.question.text().strip()
        if not question:
            return

        # Disable buttons during processing
        self.dlg.send_chat.setEnabled(False)
        self.dlg.question.setEnabled(False)

        try:
            # Get settings from UI
            temperature = self.dlg.temperature.value()
            max_tokens = self.dlg.max_tokens.value()
            model_name = self.dlg.model.currentText()

            # Display user question
            self._display_user_message(question)

            # Initialize app if needed or model changed
            if self.app is None or self.current_model != model_name:
                self._initialize_agent(
                    model_name, temperature=temperature, max_tokens=max_tokens
                )

            # Rebuild app if temperature changed
            if (
                self._last_temperature is None
                or abs(self._last_temperature - temperature) > 1e-9
            ):
                # Recreate LLM and app to apply new temperature
                self._initialize_agent(
                    model_name, temperature=temperature, max_tokens=max_tokens
                )
                self._last_temperature = temperature

            if self.app is None:
                raise RuntimeError("LLM app is not initialized")

            # Prepare messages
            SystemMessage, HumanMessage = self._get_message_classes()

            # On first turn, seed the thread with system prompt
            if not self._has_started_thread:
                # Initialize thread with system message
                init_state = {
                    "messages": [SystemMessage(content=GENERAL_SYSTEM_PROMPT)]
                }
                self.app.invoke(
                    init_state, config={"configurable": {"thread_id": self.thread_id}}
                )
                self._has_started_thread = True

            # Now invoke with just the new user message; graph will load history from checkpoint
            msgs = [HumanMessage(content=question)]
            _, invoke_app = self._get_agents_general()
            ai_msg = invoke_app(self.app, thread_id=self.thread_id, messages=msgs)
            response_text = (
                ai_msg.content if hasattr(ai_msg, "content") else str(ai_msg)
            )

            # Display response
            self._display_ai_response(response_text)

            # Clear input and scroll to bottom
            self.dlg.question.setText("")
            self._scroll_to_bottom()

        except Exception as e:
            error_msg = f"Error: {str(e)}"
            self._log_error("send_message", e)
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                error_msg,
                level=Qgis.Critical,
                duration=QGIS_MESSAGE_DURATION,
            )
            # Show a popup with a hint to the log location
            try:
                if DEBUG_MODE:
                    self.showMessage(
                        "GeoAgent Error",
                        f"{error_msg}\n\nSee full log at:\n{self._error_log_path}",
                        "OK",
                        "Warning",
                    )
            except Exception:
                pass
        finally:
            # Re-enable buttons
            self.dlg.send_chat.setEnabled(True)
            self.dlg.question.setEnabled(True)

    def _initialize_agent(
        self, model_name: str, temperature: float = 0.7, max_tokens: int = None
    ) -> None:
        """Initialize the LangChain chat model and LangGraph app."""
        try:
            if model_name not in SUPPORTED_MODELS:
                raise ValueError(f"Unsupported model: {model_name}")

            model_config = SUPPORTED_MODELS[model_name]
            provider = model_config["type"]

            # Get API key if required
            api_key = None
            if model_config.get("requires_api_key"):
                api_key = self.dlg.custom_apikey.text().strip()
                if not api_key:
                    api_key = self.api_key
                if not api_key:
                    raise ValueError(f"API key required for {model_name}")

            # Create LLM based on provider
            client_kwargs = {"temperature": temperature, "max_tokens": max_tokens}
            if provider == "ollama":
                # Use UI-provided Ollama model name if specified; else default to llama3.2:3b
                try:
                    ollama_model_name = (
                        self.dlg.ollama_model_name.text().strip()
                        if hasattr(self.dlg, "ollama_model_name")
                        else ""
                    )
                except Exception:
                    ollama_model_name = ""

                # Optional base URL from UI; default to http://localhost:11434
                try:
                    ollama_base_url = (
                        self.dlg.ollama_base_url.text().strip()
                        if hasattr(self.dlg, "ollama_base_url")
                        else ""
                    )
                except Exception:
                    ollama_base_url = ""

                client_kwargs["model"] = (
                    ollama_model_name if ollama_model_name else "llama3.2:3b"
                )
                if ollama_base_url:
                    client_kwargs["base_url"] = ollama_base_url
            elif provider == "openai":
                client_kwargs["model"] = model_config.get(
                    "default_model", "gpt-3.5-turbo"
                )
            elif provider == "google":
                client_kwargs["model"] = model_config.get("default_model", "gemini-pro")
            # Validate Ollama availability/model
            if provider == "ollama":
                base_url = client_kwargs.get("base_url", "http://localhost:11434")
                model_str = client_kwargs.get("model", "llama3.2:3b")
                if not ollama_model_exists(base_url, model_str):
                    reply = QMessageBox.question(
                        self.iface.mainWindow(),
                        "Ollama Model Not Found",
                        f"The model '{model_str}' is not installed.\n\n"
                        f"Would you like to pull it now? This may take a few minutes.",
                        QMessageBox.Yes | QMessageBox.No,
                    )
                    if reply == QMessageBox.Yes:
                        self.iface.messageBar().pushMessage(
                            "GeoAgent",
                            f"Pulling model '{model_str}'. This may take a few minutes...",
                            level=Qgis.Info,
                            duration=QGIS_MESSAGE_DURATION,
                        )
                        if not ollama_pull_model(base_url, model_str):
                            raise RuntimeError(
                                f"Failed to pull '{model_str}'. Check Ollama server."
                            )
                        self.iface.messageBar().pushMessage(
                            "GeoAgent",
                            f"Successfully pulled '{model_str}'. Initializing...",
                            level=Qgis.Success,
                            duration=QGIS_MESSAGE_DURATION,
                        )
                    else:
                        raise RuntimeError(
                            f"Model '{model_str}' not installed. To install manually, run: ollama pull {model_str}"
                        )

            # Create LLM and compile LangGraph app
            self.llm = create_llm(provider, api_key=api_key, **client_kwargs)
            build_graph_app, _invoke_app = self._get_agents_general()
            self.app = build_graph_app(self.llm)
            self.current_model = model_name
            # Reset thread on re-init
            self.thread_id = f"geo-agent:{model_name}"
            self._has_started_thread = False

            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Connected to {model_name}",
                level=Qgis.Success,
                duration=QGIS_MESSAGE_DURATION,
            )

        except Exception as e:
            self._log_error("_initialize_agent", e)
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Failed to initialize {model_name}: {str(e)}",
                level=Qgis.Critical,
                duration=QGIS_MESSAGE_DURATION,
            )
            try:
                self.showMessage(
                    "Initialization Error",
                    f"Failed to initialize {model_name}: {str(e)}\n\nSee full log at:\n{self._error_log_path}",
                    "OK",
                    "Warning",
                )
            except Exception:
                pass
            self.llm = None
            self.app = None
            raise

    def _display_user_message(self, message: str) -> None:
        """Display user message in the chat area."""
        self.dlg.chatgpt_ans.append("\n")
        self.dlg.chatgpt_ans.append("." * 40)
        self.dlg.chatgpt_ans.append(f"\n<b>user:</b> {message}")
        # Show a processing indicator immediately
        self.dlg.chatgpt_ans.append("\n<i>Agent is processingâ€¦</i>")
        try:
            self.dlg.chatgpt_ans.repaint()
        except Exception:
            pass
        self._scroll_to_bottom()

    def _display_ai_response(self, response: str) -> None:
        """Display AI response in the chat area."""
        # Get cursor and remove the processing indicator line
        cursor = self.dlg.chatgpt_ans.textCursor()
        cursor.movePosition(cursor.End)
        # Move back to select the "Agent is processing..." line
        cursor.select(cursor.LineUnderCursor)
        cursor.removeSelectedText()
        # Remove the extra newline if present
        cursor.deletePreviousChar()

        # Append agent response
        formatted_response = response.replace("\n", "<br>")
        self.dlg.chatgpt_ans.append(f"\n<b>Agent:</b> ")
        self.dlg.chatgpt_ans.insertHtml(formatted_response)
        self.dlg.chatgpt_ans.append("\n" + "." * 40)

    def _scroll_to_bottom(self) -> None:
        """Scroll chat area to the bottom."""
        scroll_bar = self.dlg.chatgpt_ans.verticalScrollBar()
        scroll_bar.setValue(scroll_bar.maximum())

    def _load_api_key(self) -> str:
        """Load API key from file if it exists."""
        try:
            if os.path.exists(API_KEY_FILE):
                with open(API_KEY_FILE, "r") as f:
                    return f.read().strip()
        except Exception:
            pass
        return ""

    def _save_api_key(self, api_key: str) -> None:
        """Save API key to file."""
        try:
            os.makedirs(os.path.dirname(API_KEY_FILE), exist_ok=True)
            with open(API_KEY_FILE, "w") as f:
                f.write(api_key)
            self.api_key = api_key
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Failed to save API key: {str(e)}",
                level=Qgis.Warning,
                duration=QGIS_MESSAGE_DURATION,
            )

    def export_chat(self) -> None:
        """Export chat history to a text file."""
        try:
            from qgis.PyQt.QtWidgets import QFileDialog
            import datetime

            # Get chat content
            chat_text = self.dlg.chatgpt_ans.toPlainText()
            if not chat_text.strip():
                self.iface.messageBar().pushMessage(
                    "GeoAgent",
                    "Chat is empty. Nothing to export.",
                    level=Qgis.Info,
                    duration=QGIS_MESSAGE_DURATION,
                )
                return

            # Ask user where to save
            file_path, _ = QFileDialog.getSaveFileName(
                self.dlg,
                "Export Chat",
                f"geo_agent_chat_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                "Text Files (*.txt);;All Files (*)",
            )

            if file_path:
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write(chat_text)
                self.iface.messageBar().pushMessage(
                    "GeoAgent",
                    f"Chat exported to {file_path}",
                    level=Qgis.Success,
                    duration=QGIS_MESSAGE_DURATION,
                )
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Failed to export chat: {str(e)}",
                level=Qgis.Critical,
                duration=QGIS_MESSAGE_DURATION,
            )

    def clear_chat(self) -> None:
        """Clear the chat history."""
        try:
            self.dlg.chatgpt_ans.clear()
            # Start a fresh thread id (clears memory)
            import uuid

            self.thread_id = f"geo-agent:{uuid.uuid4().hex}"
            self._has_started_thread = False
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                "Chat cleared.",
                level=Qgis.Info,
                duration=QGIS_MESSAGE_DURATION,
            )
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Failed to clear chat: {str(e)}",
                level=Qgis.Critical,
                duration=5,
            )
