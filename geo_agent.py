# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoAgent
                                 A QGIS plugin
 Plugin for geospatial workflow
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-12-15
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Tek Kshetri
        email                : iamtekson@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QSizePolicy
from qgis.PyQt.QtGui import QFont
from qgis.core import Qgis

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .geo_agent_dialog import GeoAgentDialog

# Import agent and LLM components
from .config.settings import (
    API_KEY_FILE,
    SUPPORTED_MODELS,
    DEFAULT_MODEL,
    DEFAULT_TEMPERATURE,
    DEFAULT_MAX_TOKENS,
)
from .llm.client import create_client
from .agents.general import GeneralModeAgent, LangGraphGeneralAgent

import os
import os.path

# TODO: Check for the required packages whether or not installed
PACKAGE_INSTALLED = True


class GeoAgent:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "GeoAgent_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&GeoAgent")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Agent and LLM components
        self.agent = None
        self.llm_client = None
        self.current_model = DEFAULT_MODEL
        self.api_key = self._load_api_key()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("GeoAgent", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/geo_agent/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("geoAgent"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&GeoAgent"), action)
            self.iface.removeToolBarIcon(action)

        if hasattr(self, "dlg"):
            self.iface.removeDockWidget(self.dlg)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GeoAgentDialog(self.iface.mainWindow())
            # Prefer bottom dock area and allow only bottom
            try:
                self.dlg.setAllowedAreas(Qt.BottomDockWidgetArea)
            except Exception:
                pass
            self.iface.addDockWidget(Qt.BottomDockWidgetArea, self.dlg)
            # Encourage larger content footprint in bottom area
            try:
                # Increase minimum height on dock and its main widget if accessible
                self.dlg.setMinimumHeight(300)
                if hasattr(self.dlg, "widget") and callable(
                    getattr(self.dlg, "widget")
                ):
                    w = self.dlg.widget()
                    if w is not None:
                        w.setMinimumHeight(300)
                        sp = w.sizePolicy()
                        sp.setVerticalPolicy(QSizePolicy.Expanding)
                        sp.setHorizontalPolicy(QSizePolicy.Expanding)
                        w.setSizePolicy(sp)
            except Exception:
                pass
            # Wire up UI actions
            if hasattr(self.dlg, "send_chat"):
                try:
                    self.dlg.send_chat.clicked.disconnect()
                except Exception:
                    pass
                self.dlg.send_chat.clicked.connect(self.send_message)
            if hasattr(self.dlg, "question") and hasattr(
                self.dlg.question, "returnPressed"
            ):
                try:
                    self.dlg.question.returnPressed.disconnect()
                except Exception:
                    pass
                self.dlg.question.returnPressed.connect(self.send_message)
            # Wire up export and clear buttons
            if hasattr(self.dlg, "export_ans"):
                try:
                    self.dlg.export_ans.clicked.disconnect()
                except Exception:
                    pass
                self.dlg.export_ans.clicked.connect(self.export_chat)
            if hasattr(self.dlg, "clear_ans"):
                try:
                    self.dlg.clear_ans.clicked.disconnect()
                except Exception:
                    pass
                self.dlg.clear_ans.clicked.connect(self.clear_chat)

        # show and focus the dock widget
        self.dlg.show()
        self.dlg.raise_()
        self.dlg.activateWindow()
        # Try to give it a reasonable initial height in bottom area
        try:
            # Ask for more vertical space in bottom dock area
            self.iface.mainWindow().resizeDocks([self.dlg], [300], Qt.Vertical)
        except Exception:
            pass

    def showMessage(self, title, msg, button, icon, fontsize=9):
        msgBox = QMessageBox()
        if icon == "Warning":
            msgBox.setIcon(QMessageBox.Warning)
        if icon == "Info":
            msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(title)
        msgBox.setText(msg)
        msgBox.setStandardButtons(QMessageBox.Ok)
        msgBox.setStyleSheet(
            "background-color: rgb(83, 83, 83);color: rgb(255, 255, 255);"
        )
        font = QFont()
        font.setPointSize(fontsize)
        msgBox.setFont(font)
        msgBox.setWindowFlags(Qt.Dialog | Qt.WindowStaysOnTopHint)
        buttonY = msgBox.button(QMessageBox.Ok)
        buttonY.setText(button)
        buttonY.setFont(font)
        msgBox.exec_()

    def send_message(self):
        """Send a message and get a response from the LLM."""
        # Validate input
        question = self.dlg.question.text().strip()
        if not question:
            return

        # Disable buttons during processing
        self.dlg.send_chat.setEnabled(False)
        self.dlg.question.setEnabled(False)

        try:
            # Get settings from UI
            temperature = self.dlg.temperature.value()
            max_tokens = self.dlg.max_tokens.value()
            model_name = self.dlg.model.currentText()

            # Display user question
            self._display_user_message(question)

            # Initialize agent if needed or model changed
            if self.agent is None or self.current_model != model_name:
                self._initialize_agent(model_name)

            if self.agent is None:
                raise RuntimeError("Failed to initialize LLM agent")

            # Get response from agent
            response = self.agent.process_query(
                question, temperature=temperature, max_tokens=max_tokens
            )

            # Display response
            self._display_ai_response(response)

            # Clear input and scroll to bottom
            self.dlg.question.setText("")
            self._scroll_to_bottom()

        except Exception as e:
            error_msg = f"Error: {str(e)}"
            self.iface.messageBar().pushMessage(
                "GeoAgent", error_msg, level=Qgis.Critical, duration=5
            )
        finally:
            # Re-enable buttons
            self.dlg.send_chat.setEnabled(True)
            self.dlg.question.setEnabled(True)

    def _initialize_agent(self, model_name: str) -> None:
        """Initialize the LLM agent with the selected model."""
        try:
            if model_name not in SUPPORTED_MODELS:
                raise ValueError(f"Unsupported model: {model_name}")

            model_config = SUPPORTED_MODELS[model_name]
            provider = model_config["type"]

            # Get API key if required
            api_key = None
            if model_config.get("requires_api_key"):
                api_key = self.dlg.custom_apikey.text().strip()
                if not api_key:
                    api_key = self.api_key
                if not api_key:
                    raise ValueError(f"API key required for {model_name}")

            # Create LLM client based on provider
            client_kwargs = {}
            if provider == "ollama":
                # Use UI-provided Ollama model name if specified; else default to llama3.2:3b
                try:
                    ollama_model_name = (
                        self.dlg.ollama_model_name.text().strip()
                        if hasattr(self.dlg, "ollama_model_name")
                        else ""
                    )
                except Exception:
                    ollama_model_name = ""

                # Optional base URL from UI; default to http://localhost:11434
                try:
                    ollama_base_url = (
                        self.dlg.ollama_base_url.text().strip()
                        if hasattr(self.dlg, "ollama_base_url")
                        else ""
                    )
                except Exception:
                    ollama_base_url = ""

                client_kwargs["model"] = (
                    ollama_model_name if ollama_model_name else "llama3.2:3b"
                )
                if ollama_base_url:
                    client_kwargs["base_url"] = ollama_base_url
            elif provider == "openai":
                client_kwargs["model"] = model_config.get(
                    "default_model", "gpt-3.5-turbo"
                )
            elif provider == "google":
                client_kwargs["model"] = model_config.get("default_model", "gemini-pro")

            self.llm_client = create_client(provider, api_key=api_key, **client_kwargs)

            # Validate connection
            if not self.llm_client.validate_connection():
                if provider == "ollama":
                    # Check if model is missing and offer to pull it
                    if (
                        hasattr(self.llm_client, "_model_missing")
                        and self.llm_client._model_missing
                    ):
                        model_str = getattr(self.llm_client, "model", "llama3.2:3b")
                        reply = QMessageBox.question(
                            self.iface.mainWindow(),
                            "Ollama Model Not Found",
                            f"The model '{model_str}' is not installed.\n\n"
                            f"Would you like to pull it now? This may take a few minutes.",
                            QMessageBox.Yes | QMessageBox.No,
                        )

                        if reply == QMessageBox.Yes:
                            self.iface.messageBar().pushMessage(
                                "GeoAgent",
                                f"Pulling model '{model_str}'. This may take a few minutes...",
                                level=Qgis.Info,
                                duration=0,
                            )
                            try:
                                if self.llm_client.pull_model():
                                    self.iface.messageBar().pushMessage(
                                        "GeoAgent",
                                        f"Successfully pulled '{model_str}'. Initializing...",
                                        level=Qgis.Success,
                                        duration=3,
                                    )
                                    # Retry validation after pull
                                    if self.llm_client.validate_connection():
                                        self.agent = LangGraphGeneralAgent(
                                            self.llm_client
                                        )
                                        self.current_model = model_name
                                        self.iface.messageBar().pushMessage(
                                            "GeoAgent",
                                            f"Connected to {model_name}",
                                            level=Qgis.Success,
                                            duration=3,
                                        )
                                        return
                                    else:
                                        raise RuntimeError(
                                            f"Model pulled but validation still failed."
                                        )
                                else:
                                    raise RuntimeError(
                                        f"Failed to pull '{model_str}'. Check Ollama logs."
                                    )
                            except Exception as pull_err:
                                self.iface.messageBar().pushMessage(
                                    "GeoAgent",
                                    f"Error pulling model: {str(pull_err)}",
                                    level=Qgis.Critical,
                                    duration=5,
                                )
                                raise RuntimeError(
                                    f"Model pull failed: {str(pull_err)}"
                                )
                        else:
                            raise RuntimeError(
                                f"Model '{model_str}' not installed. "
                                f"To install manually, run: ollama pull {model_str}"
                            )
                    else:
                        # Server not reachable
                        hint = None
                        if hasattr(self.llm_client, "explain_validate_failure"):
                            try:
                                hint = self.llm_client.explain_validate_failure()
                            except Exception:
                                hint = None
                        if not hint:
                            hint = f"Cannot connect to Ollama at {getattr(self.llm_client, 'base_url', 'http://localhost:11434')}"
                        raise RuntimeError(hint)
                else:
                    raise RuntimeError(f"Cannot connect to {model_name}")

            # Create agent (use LangGraph-based agent for general mode)
            self.agent = LangGraphGeneralAgent(self.llm_client)
            self.current_model = model_name

            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Connected to {model_name}",
                level=Qgis.Success,
                duration=3,
            )

        except Exception as e:
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Failed to initialize {model_name}: {str(e)}",
                level=Qgis.Critical,
                duration=5,
            )
            self.agent = None
            self.llm_client = None
            raise

    def _display_user_message(self, message: str) -> None:
        """Display user message in the chat area."""
        self.dlg.chatgpt_ans.append("\n")
        self.dlg.chatgpt_ans.append("." * 40)
        self.dlg.chatgpt_ans.append(f"\n<b>user:</b> {message}")
        # Show a processing indicator immediately
        self.dlg.chatgpt_ans.append("\n<i>Agent is processingâ€¦</i>")
        try:
            self.dlg.chatgpt_ans.repaint()
        except Exception:
            pass
        self._scroll_to_bottom()

    def _display_ai_response(self, response: str) -> None:
        """Display AI response in the chat area."""
        # Get cursor and remove the processing indicator line
        cursor = self.dlg.chatgpt_ans.textCursor()
        cursor.movePosition(cursor.End)
        # Move back to select the "Agent is processing..." line
        cursor.select(cursor.LineUnderCursor)
        cursor.removeSelectedText()
        # Remove the extra newline if present
        cursor.deletePreviousChar()

        # Append agent response
        formatted_response = response.replace("\n", "<br>")
        self.dlg.chatgpt_ans.append(f"\n<b>Agent:</b> ")
        self.dlg.chatgpt_ans.insertHtml(formatted_response)
        self.dlg.chatgpt_ans.append("\n" + "." * 40)

    def _scroll_to_bottom(self) -> None:
        """Scroll chat area to the bottom."""
        scroll_bar = self.dlg.chatgpt_ans.verticalScrollBar()
        scroll_bar.setValue(scroll_bar.maximum())

    def _load_api_key(self) -> str:
        """Load API key from file if it exists."""
        try:
            if os.path.exists(API_KEY_FILE):
                with open(API_KEY_FILE, "r") as f:
                    return f.read().strip()
        except Exception:
            pass
        return ""

    def _save_api_key(self, api_key: str) -> None:
        """Save API key to file."""
        try:
            os.makedirs(os.path.dirname(API_KEY_FILE), exist_ok=True)
            with open(API_KEY_FILE, "w") as f:
                f.write(api_key)
            self.api_key = api_key
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "GeoAgent", f"Failed to save API key: {str(e)}", level=Qgis.Warning
            )

    def export_chat(self) -> None:
        """Export chat history to a text file."""
        try:
            from qgis.PyQt.QtWidgets import QFileDialog
            import datetime

            # Get chat content
            chat_text = self.dlg.chatgpt_ans.toPlainText()
            if not chat_text.strip():
                self.iface.messageBar().pushMessage(
                    "GeoAgent",
                    "Chat is empty. Nothing to export.",
                    level=Qgis.Info,
                    duration=3,
                )
                return

            # Ask user where to save
            file_path, _ = QFileDialog.getSaveFileName(
                self.dlg,
                "Export Chat",
                f"geo_agent_chat_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                "Text Files (*.txt);;All Files (*)",
            )

            if file_path:
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write(chat_text)
                self.iface.messageBar().pushMessage(
                    "GeoAgent",
                    f"Chat exported to {file_path}",
                    level=Qgis.Success,
                    duration=3,
                )
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Failed to export chat: {str(e)}",
                level=Qgis.Critical,
                duration=5,
            )

    def clear_chat(self) -> None:
        """Clear the chat history."""
        try:
            self.dlg.chatgpt_ans.clear()
            if self.agent is not None:
                self.agent.clear_history()
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                "Chat cleared.",
                level=Qgis.Info,
                duration=2,
            )
        except Exception as e:
            self.iface.messageBar().pushMessage(
                "GeoAgent",
                f"Failed to clear chat: {str(e)}",
                level=Qgis.Critical,
                duration=5,
            )
